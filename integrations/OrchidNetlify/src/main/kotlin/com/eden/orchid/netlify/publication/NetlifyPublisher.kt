// Generated by delombok at Sun Mar 24 19:34:08 CDT 2019
package com.eden.orchid.netlify.publication

import com.caseyjbrooks.clog.Clog
import com.eden.orchid.api.OrchidContext
import com.eden.orchid.api.options.annotations.Description
import com.eden.orchid.api.options.annotations.Option
import com.eden.orchid.api.publication.OrchidPublisher
import com.eden.orchid.utilities.OrchidUtils
import okhttp3.MediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody
import okhttp3.Response
import org.apache.commons.io.FileUtils
import org.json.JSONObject
import java.io.File
import java.text.SimpleDateFormat
import java.time.Duration
import java.time.Instant
import java.util.ArrayList
import javax.inject.Inject
import javax.inject.Named
import javax.validation.constraints.NotBlank

@Description(value = "Upload your site directly to Netlify, while using your favorite CI platform.", name = "Netlify")
class NetlifyPublisher @Inject
constructor(
    context: OrchidContext,
    private val client: OkHttpClient,

    @Named("dest")
    private val destinationDir: String,

    @Named("netlifyToken")
    @NotBlank(message = "A Netlify Personal Access Token is required for deploys, set as \'netlifyToken\' flag")
    val netlifyToken: String
) : OrchidPublisher(context, "netlify", 100) {

    @Option
    @Description("Your Netlify site ID or domain (ie. orchid.netlify.com).")
    @NotBlank(message = "A Netlify site domain must be provided.")
    lateinit var siteId: String

    private var filesUploaded = 0

    override fun validate(): Boolean {
        var valid = super.validate()
        // make sure the site exists
        val site = getFrom("sites/$siteId").call(client)
        if (!site.first) {
            Clog.e("A Netlify site at {} does not exist or it cannot be accessed.", siteId)
            valid = false
        }
        return valid
    }

    override fun publish() {
        doNetlifyDeploy()
    }

    private fun doNetlifyDeploy() {
        val file = File(destinationDir)
        val fileMap = mutableMapOf<String, MutableList<File>>()

        // create digest of files to be uploaded
        val body = JSONObject()
        val bodyFiles = JSONObject()

        if (file.exists() && file.isDirectory) {
            FileUtils.listFiles(file, null, true)
                .filter { it.isFile }
                .forEach {
                    val path = OrchidUtils.getRelativeFilename(it.absolutePath, destinationDir)
                    val sha1 = OrchidUtils.sha1(it)
                    bodyFiles.put(path, sha1)
                    fileMap.computeIfAbsent(sha1) { ArrayList() }.add(it)
                }
        }

        body.put("files", bodyFiles)
        // post to Netlify to determine which files need to be uploaded still
        val requiredFilesResponse = body.postTo("sites/{}/deploys", body, siteId).call(client)
        if (!requiredFilesResponse.first) {
            throw RuntimeException("something went wrong attempting to deploy to Netlify: " + requiredFilesResponse.second)
        }

        val requiredFiles = JSONObject(requiredFilesResponse.second)
        if (requiredFiles.getJSONArray("required").length() == 0) {
            Clog.i("All files up-to-date on Netlify.")
        } else {
            filesUploaded = 0
            // upload all required files
            val deployId = requiredFiles.getString("id")
            val totalFiles = requiredFiles.getJSONArray("required").length()
            Clog.i("Uploading {} files to Netlify.", totalFiles)

            requiredFiles
                .getJSONArray("required")
                .filterNotNull()
                .map { o -> o.toString() }
                .flatMap { sha1ToUpload -> fileMap.getOrDefault(sha1ToUpload, ArrayList()) }
                .forEach { fileToUpload ->
                    val path = OrchidUtils.getRelativeFilename(fileToUpload.absolutePath, destinationDir)
                    fileToUpload.uploadTo("{}/deploys/{}/files/{}", totalFiles, netlifyUrl, deployId, path).call(client)
                }
        }
    }

    /**
     * This method will start the Netlify deploy using their async method, which is needed to deploy really large sites.
     * It will make the initial request, then poll for a while until either the site is ready or a timeout is reached.
     * That timeout is proportional to the number of files being uploaded.
     */
    private fun startDeploySite() {

    }

    /**
     * Upload the required files to Netlify as site files as requested from the initial deploy call.
     */
    private fun uploadRequiredFiles() {

    }

    /**
     * Upload the required files to Netlify as serverless functions as requested from the initial deploy call.
     */
    private fun uploadRequiredFunctions() {

    }

    private fun getFrom(url: String, vararg args: Any): Request {
        val fullURL = Clog.format("$netlifyUrl/$url", *args)
        Clog.d("Netlify GET: {}", fullURL)
        return newRequest(url)
            .get()
            .build()
    }

    private fun JSONObject.postTo(url: String, vararg args: Any): Request {
        val fullURL = Clog.format("$netlifyUrl/$url", *args)
        Clog.d("Netlify POST: {}", fullURL)
        return newRequest(url)
            .post(RequestBody.create(JSON, this.toString()))
            .build()
    }

    private fun File.uploadTo(url: String, totalFiles: Int, vararg args: Any): Request {
        val fullURL = Clog.format(url, *args)
        filesUploaded++
        Clog.d("Netlify UPLOAD {}/{}: {}", filesUploaded, totalFiles, fullURL)

        return newRequest(fullURL)
            .put(RequestBody.create(BINARY, this))
            .build()
    }

    private fun newRequest(url: String): Request.Builder {
        return Request.Builder()
            .url(url)
            .header("Authorization", "Bearer $netlifyToken")
    }

    private fun Request.call(client: OkHttpClient) : Pair<Boolean, String> {
        val response = client
            .newCall(this)
            .execute()
            .timeoutRateLimit()

        return try {
            val bodyString = response.body()!!.string()
            if (!response.isSuccessful) {
                Clog.e("{}", bodyString)
            }
            response.isSuccessful to bodyString
        } catch (e: Exception) {
            e.printStackTrace()
            false to ""
        }
    }

    private fun Response.timeoutRateLimit(): Response {
        try {
            val RateLimit_Limit = Integer.parseInt(header("X-RateLimit-Limit")!!)
            val RateLimit_Remaining = Integer.parseInt(header("X-RateLimit-Remaining")!!)
            val RateLimit_Reset =
                SimpleDateFormat("yyyy-MM-dd HH:mm:ss Z").parse(header("X-RateLimit-Reset")).toInstant()
            val current = Instant.now()
            val d = Duration.between(RateLimit_Reset, current)
            // if we are nearing the rate limit, pause down a bit until it resets
            if (RateLimit_Remaining * 1.0 / RateLimit_Limit * 1.0 < 0.1) {
                Thread.sleep(Math.abs(d.toMillis()))
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }

        return this
    }

    companion object {
        private val JSON = MediaType.parse("application/json; charset=utf-8")
        private val BINARY = MediaType.parse("application/octet-stream")
        private const val netlifyUrl = "https://api.netlify.com/api/v1"
    }
}
